# Опыт работы с библиотеками и фреймворками
Сильный разработчик расскажет о большом количестве библиотек, которые были использованы. По ходу повествования лучше всего уточнять почему выбрана именно эта библиотека, какие у неё конкуренты, с какими проблемами при использовании сталкивался и т.п. Если кандидат сам об этом будет говорить, то это ещё лучше.

# Структуры данных
В питоне существует несколько базовых структур данных:
- Числа (`int`, `float`, `decimal`, `fraction`, `complex`)
- Строки и байты (`str`, `bytes`, `bytearray`)
- Контейнеры (`list`, `dict`, `tuple`, `set`, `frozenset`)

### Контейнеры по назначению:
#### `list`
Упорядоченная мутабельная последовательность объектов. Это не линейный список, а массив с динамическим размером. Линейный список это `collections.deque`.
Сложность основных операций:
- Выборка элемента по индексу O(1)
- Добавление элемента в конец O(1)
- Добавление элемента в начало O(n)
#### `dict`
Неупорядоченный мутабельный key-value контейнер.
Сложность основных операций:
- Выборка элемента по ключу O(1)
- Вставка элемента по ключу O(1)
#### `tuple`
Упорядоченная иммутабельная хешируемая последовательность объектов.
Сложность основных операций:
- Выборка элемента по индексу O(1)
#### `set`
Неупорядоченная мутабельная последовательность объектов.
Сложность основных операций:
- Проверка на вхождение O(1)
- Добавление элемента O(1)
#### `frozenset`
Неупорядоченная иммутабельная хешируемая последовательность объектов.
Сложность основных операций:
- Проверка на вхождение O(1)
- Добавление элемента O(1)

Можно классифицировать по некоторым параметрам

### По мутабельности
- Иммутабельные (`int`, `float`, `decimal`, `fraction`, `complex`, `str`, `bytes`, `tuple`, `frozenset`)
- Мутабельные (`bytearray`, `list`, `dict`, `set`)

### По хешируемости
Общее правило: иммутабельные объекты хешируемы, но ничто не мешает переопределить метод `__hash__` для мутабельных объектов. При этом корень правила в том, что при изменении мутабельного объекта его хеш меняется. Хешируемость позволяет использовать объекты как ключи в словарях (`dict`) и как элементы наборов (`set`). В целом, иммутабельность это тренд. Мутабельность нужна для ресурсоёмких операций.

# `pep8`
Это стандарт оформления питоновского кода. Также существуют утилиты для проверки соответствия кода этому стандарту (линтеры), например flake8, утилиты для автоматического форматирования кода согласно этому стандарту, например `black`.

# Аннотация типов
Питон — язык с динамической типизацией. Поэтому типы в коде не указываются. Однако со временем в языке появилась возможность указать тип переменных, возвращаемых функциями объектов и т.д. На рантайм они никак не влияют, но позволяют использовать специальные утилиты для проверки корректности программ с точки зрения типов, например `mypy`.

# context manager
Контекстный менеджер позволяет скрывать инициализацию и финализацию объектов от пользователя не принуждая его использовать их явно. Вместо этого пользователю даётся единственный способ использования, при котором инициализация и финализация исполняются в любом случае, независимо от кода, который использует контекст. Это позволяет исключить ситуацию, когда пользователь забывает вызвать финализацию. Например открыть/закрыть файл.

``` python
f = open("some.txt")
data = f.read()
f.close()

with open("some.txt") as f:
    data = f.read()
```

# Декоратор
Это функция, принимающая на вход функцию и возвращающая функцию. Для применения есть специальная конструкция в языке. Нужен чтобы модифицировать поведение функций не добавляя в них код. Может использоваться для пред/пост обработки данных, скрытия какого-то повторяющегося действия и т.д.

``` python
def decorator(f):
    @functools.wraps
    def wrapper(*args, **kwargs):
        start = time.time()
        f(*args, **kwargs)
        end = time.time()
        print("function time is", end - start)
    return wrapper

@decorator
def f():
    time.sleep(1)
```

# Генератор
Это особая функция, которая может выдавать и принимать значения несколько раз. Зачастую используется как итератор (ничего не принимает извне, только выдаёт). Над объектом генератора есть методы `send`, `throw`, `close`. Они позволяют посылать/принимать значения в/из генератора, а также бросать в него исключения. Используется в основном для ленивого исполнения кода. В случае функции пока все элементы последовательности не будут вычислены и агрегированны в контейнер (список, словарь) функция не выдаст ничего. В случае генератора — каждое очередное значение выдаётся как только оно вычисленно.

``` python
def fib(n):
    numbers = []
    a, b = 0, 1
    for _ in range(n):
        numbers.append(a)
        a, b = b, a + b
    return numbers

def fib_gen(n):
    a, b = 0, 1
    for _ in range(n):
        yield a
        a, b = b, a + b

for x in fib_gen(10):
    print(x)
```

# GIL
Global interpreter lock. Примитив синхронизации для поддержания консистентного состояния интерпретатора. Как любой lock-примитив может быть "захвачен" и "отпущен". Когда захвачен, никакой другой поток питона уровня ОС не может выполнять какие-либо действия. Очень выгодно его "отпускать" чтобы многопоточность работала. Отпускается на системные вызовы, потому что они не могут повлиять на состояние интерпретатора (ввод/вывод в файлы/сокеты например). Поэтому для веб-приложений GIL не играет особой роли, потому что 99% времени веб-приложения ждут сетевой активности. Негативный эффект появляется при большом количестве запросов (тысячи в секунду) и при выполнении длительных операций без отпускания GIL (например вычисления на питоне).

# async/await
Асинхронное программирование в питоне построено на генераторах. Позволяет экономить ресурсы не создавая системные потоки и использовать агрегированный системный вызов (select, epoll, etc) для нескольких сущностей (в основном сокеты). Также by design снижает потребность в примитивах синхронизации, потому что переключение контекста может происходит только когда управление передаётся event loop. Основные части: event loop + coroutines (по сути генераторы). Event loop собирает "заявки" от корутин на какие-то действия, агрегирует их и делает системный вызов. Как только какая-либо заявка исполнена, event loop продолжает выполнение корутины, которая эту заявку "разместила". Отрицательной стороной asyncio является то, что ни одна библиотека, которая использует классический подход, не может быть использована в асинхронном приложении, потому что она не умеет общаться с event loop.
